## 1、基础

### 场景加载

~~~C#
Application.LoadLevel(string sceneName);
Application.LoadLevelAdditive(string sceneName);
Application.LoadLevelAsync(string sceneName);
Application.LoadLevelAdditiveAsync(string sceneName);
~~~

### 分辨率适配

设置`Canvas` 的 UI Scale Mode 

### 资源加载

#### 1、Resources 

加载本地资源，存放路径为工程下Resources目录下。路径可采用相对于Resources的相对路径。

~~~C#
Object obj = Resources.Load(string path)
~~~

#### 2、StreamingAssets

工程中放在StreamingAssets下的资源。IO 或者 WWW.Load()。IO仅限于bytes和text

#### 3、WWW

主要是拉取网络上的更新资源。

### 设置对象可见

~~~C#
GameObject.SetActive(bool isActive)
~~~

### 本地配置

~~~C#
// 存储配置
PlayerPrefs.SetString("key", "value");
PlayerPrefs.SetInt("key", 1);
PlayerPrefs.SetDouble("key", 1.0);

// 获取配置（第二个参数为未取到对应值时赋给的默认值）
PlayerPrefs.GetString("key", "");
PlayerPrefs.GetInt("key", 0);
PlayerPrefs.GetFloat("key", 0.0);
~~~

## 2、多人联机

官方的UNet（NetworkManager）已弃用，后续准备用MLAPI（Your First Networked Game "Hello World" | Unity Multiplayer Networking (unity3d.com)](https://docs-multiplayer.unity3d.com/docs/tutorials/helloworld/helloworldintro/index.html)）进行替代。

官方推荐联机框架如下（都比UNet好）：

![img](https://gitee.com/gearinger/gear-markdown-pictures/raw/picgo/20211219-120135.png)

### MLAPI(Netcode)教程

参考官网[Your First Networked Game "Hello World" | Unity Multiplayer Networking (unity3d.com)](https://docs-multiplayer.unity3d.com/docs/tutorials/helloworld/helloworldintro/index.html)，本次使用unity2.5.6

#### 1、简单教程

##### （1）引入 Netcode

`package manager`中点击 `add package from git url` 导入包`com.unity.netcode.gameobjects`

##### （2）创建 `NetworkManager`

创建空物体，命名为 **NetworkManager**，给该空物体添加组件 `Network Manager`

##### （3）创建玩家 `Player`

创建 `cube`，命名为 `Player`，拖入到资源列表，形成预制体（`prefeb`），并删除场景中的 `Player`

##### （4）配置 `NetworkManager`

将预制体 `Player` 拖到 `Network Manaager` 的 `Player Prefeb` 属性中。

然后，在`Network Prefebs`中点击`+`，并添加预制体 `Player`。

启动游戏时， `Network Manaager` 会根据 `Player Prefeb` 属性自动生成预制体 `Player`。

（5）新建 `MultiPlayerManager.cs`

新建 `MultiPlayerManager.cs`，用于生成界面 `UI` 并关联 `Button` 点击事件

~~~C#
public class MultiPlayerManager : MonoBehaviour
{
    void OnGUI()
    {
        GUILayout.BeginArea(new Rect(10, 10, 300, 300));
        if (!NetworkManager.Singleton.IsClient && !NetworkManager.Singleton.IsServer)
        {
            StartButtons();
        }
        else
        {
            StatusLabels();

            SubmitNewPosition();
        }

        GUILayout.EndArea();
    }

    static void StartButtons()
    {
        if (GUILayout.Button("Host")) NetworkManager.Singleton.StartHost();
        if (GUILayout.Button("Client")) NetworkManager.Singleton.StartClient();
        if (GUILayout.Button("Server")) NetworkManager.Singleton.StartServer();
    }

    static void StatusLabels()
    {
        var mode = NetworkManager.Singleton.IsHost ?
            "Host" : NetworkManager.Singleton.IsServer ? "Server" : "Client";

        GUILayout.Label("Transport: " +
                        NetworkManager.Singleton.NetworkConfig.NetworkTransport.GetType().Name);
        GUILayout.Label("Mode: " + mode);
    }

    static void SubmitNewPosition()
    {
        if (GUILayout.Button(NetworkManager.Singleton.IsServer ? "Move" : "Request Position Change"))
        {
            var playerObject = NetworkManager.Singleton.SpawnManager.GetLocalPlayerObject();
            var player = playerObject.GetComponent<Player>();
            player.Move();
        }
    }
}
~~~

（6）添加 `Player` 的控制脚本

> 注意：此处继承的是 `NetworkBehaviour`，`NetworkBehaviour` 是继承 `MonoBehaviour`而来

~~~C#
public class Player : NetworkBehaviour
{
    public NetworkVariable<Vector3> Position = new NetworkVariable<Vector3>();

    public override void OnNetworkSpawn()
    {
        if (IsOwner)
        {
            Move();
        }
    }

    public void Move()
    {
        if (NetworkManager.Singleton.IsServer)
        {
            var randomPosition = GetRandomPositionOnPlane();
            transform.position = randomPosition;
            Position.Value = randomPosition;
        }
        else
        {
            SubmitPositionRequestServerRpc();
        }
    }

    [ServerRpc]
    void SubmitPositionRequestServerRpc(ServerRpcParams rpcParams = default)
    {
        Position.Value = GetRandomPositionOnPlane();
    }

    static Vector3 GetRandomPositionOnPlane()
    {
        return new Vector3(Random.Range(-3f, 3f), 1f, Random.Range(-3f, 3f));
    }

    void Update()
    {
        transform.position = Position.Value;
    }
}
~~~

`Server` 端可直接更改 `Player`属性，客户端需要通过 RPC 远程调用函数去更新服务端的 `Palyer` 属性。

#### 2、NetCode权限

~~~C#
using Unity.Netcode;
using Unity.Netcode.Spawning;

private void Setup() 
{
    NetworkManager.Singleton.ConnectionApprovalCallback += ApprovalCheck;
    NetworkManager.Singleton.StartHost();
}

private void ApprovalCheck(byte[] connectionData, ulong clientId, MLAPI.NetworkManager.ConnectionApprovedDelegate callback)
{
    bool approve = true;
    bool createPlayerObject = true;

    // The prefab hash. Use null to use the default player prefab
    // If using this hash, replace "MyPrefabHashGenerator" with the name of a prefab added to the NetworkPrefabs field of your NetworkManager object in the scene
    ulong? prefabHash = NetworkSpawnManager.GetPrefabHashFromGenerator("MyPrefabHashGenerator");
    
    //If approve is true, the connection gets added. If it's false. The client gets disconnected
    callback(createPlayerObject, prefabHash, approve, positionToSpawnAt, rotationToSpawnWith);
}
~~~





## 999、示例脚本

### 1、WASD控制移动

```C#
float speed = 2.0;

if (Input.GetKey(KeyCode.W))
{
    transform.Translate(speed * Time.deltaTime * Vector3.forward);
}

if (Input.GetKey(KeyCode.D))
{
    transform.Translate(speed * Time.deltaTime * Vector3.right);
}

if (Input.GetKey(KeyCode.S))
{
    transform.Translate(speed * Time.deltaTime * Vector3.back);
}

if (Input.GetKey(KeyCode.A))
{
    transform.Translate(speed * Time.deltaTime * Vector3.left);
}
```

### 2、鼠标点击移动

### 3、物体跟随鼠标移动

~~~C#
//获取鼠标在相机中（世界中）的位置，转换为屏幕坐标；
screenPosition = Camera.main.WorldToScreenPoint(transform.position);
//获取鼠标在场景中坐标
mousePositionOnScreen = Input.mousePosition;
//使鼠标坐标到屏幕的距离=物体到屏幕的距离
mousePositionOnScreen.z = screenPosition.z;
//将相机中的坐标转化为世界坐标
mousePositionInWorld = Camera.main.ScreenToWorldPoint(mousePositionOnScreen);
//物体跟随鼠标移动，保持高度不变
transform.position = new Vector3(mousePositionInWorld.x,transform.position.y,mousePositionInWorld.z);
~~~

由于update过程中存在世界点的迭代更新，所以看起来最终与鼠标点所在位置一致。

![image-20210817234531218](C:\Users\Gear\AppData\Roaming\Typora\typora-user-images\image-20210817234531218.png)

## 问题

### 1、`GameObject.Find() `无法找到 `active` 为 `false` 的对象

~~~C#
// 改用 transform 去获取
GameObject.Find("Canvas").transform.Find("Button").gameObject;
~~~

